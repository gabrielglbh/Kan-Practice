// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'daily_options_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$DailyOptionsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            int words, int grammar, int wordsMean, int grammarMean)
        loaded,
    required TResult Function() initial,
    required TResult Function() error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult? Function()? initial,
    TResult? Function()? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult Function()? initial,
    TResult Function()? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DailyOptionsLoading value) loading,
    required TResult Function(DailyOptionsLoaded value) loaded,
    required TResult Function(DailyOptionsInitial value) initial,
    required TResult Function(DailyOptionsError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DailyOptionsLoading value)? loading,
    TResult? Function(DailyOptionsLoaded value)? loaded,
    TResult? Function(DailyOptionsInitial value)? initial,
    TResult? Function(DailyOptionsError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DailyOptionsLoading value)? loading,
    TResult Function(DailyOptionsLoaded value)? loaded,
    TResult Function(DailyOptionsInitial value)? initial,
    TResult Function(DailyOptionsError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DailyOptionsStateCopyWith<$Res> {
  factory $DailyOptionsStateCopyWith(
          DailyOptionsState value, $Res Function(DailyOptionsState) then) =
      _$DailyOptionsStateCopyWithImpl<$Res, DailyOptionsState>;
}

/// @nodoc
class _$DailyOptionsStateCopyWithImpl<$Res, $Val extends DailyOptionsState>
    implements $DailyOptionsStateCopyWith<$Res> {
  _$DailyOptionsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DailyOptionsLoadingImplCopyWith<$Res> {
  factory _$$DailyOptionsLoadingImplCopyWith(_$DailyOptionsLoadingImpl value,
          $Res Function(_$DailyOptionsLoadingImpl) then) =
      __$$DailyOptionsLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DailyOptionsLoadingImplCopyWithImpl<$Res>
    extends _$DailyOptionsStateCopyWithImpl<$Res, _$DailyOptionsLoadingImpl>
    implements _$$DailyOptionsLoadingImplCopyWith<$Res> {
  __$$DailyOptionsLoadingImplCopyWithImpl(_$DailyOptionsLoadingImpl _value,
      $Res Function(_$DailyOptionsLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DailyOptionsLoadingImpl implements DailyOptionsLoading {
  const _$DailyOptionsLoadingImpl();

  @override
  String toString() {
    return 'DailyOptionsState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DailyOptionsLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            int words, int grammar, int wordsMean, int grammarMean)
        loaded,
    required TResult Function() initial,
    required TResult Function() error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult? Function()? initial,
    TResult? Function()? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult Function()? initial,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DailyOptionsLoading value) loading,
    required TResult Function(DailyOptionsLoaded value) loaded,
    required TResult Function(DailyOptionsInitial value) initial,
    required TResult Function(DailyOptionsError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DailyOptionsLoading value)? loading,
    TResult? Function(DailyOptionsLoaded value)? loaded,
    TResult? Function(DailyOptionsInitial value)? initial,
    TResult? Function(DailyOptionsError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DailyOptionsLoading value)? loading,
    TResult Function(DailyOptionsLoaded value)? loaded,
    TResult Function(DailyOptionsInitial value)? initial,
    TResult Function(DailyOptionsError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class DailyOptionsLoading implements DailyOptionsState {
  const factory DailyOptionsLoading() = _$DailyOptionsLoadingImpl;
}

/// @nodoc
abstract class _$$DailyOptionsLoadedImplCopyWith<$Res> {
  factory _$$DailyOptionsLoadedImplCopyWith(_$DailyOptionsLoadedImpl value,
          $Res Function(_$DailyOptionsLoadedImpl) then) =
      __$$DailyOptionsLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int words, int grammar, int wordsMean, int grammarMean});
}

/// @nodoc
class __$$DailyOptionsLoadedImplCopyWithImpl<$Res>
    extends _$DailyOptionsStateCopyWithImpl<$Res, _$DailyOptionsLoadedImpl>
    implements _$$DailyOptionsLoadedImplCopyWith<$Res> {
  __$$DailyOptionsLoadedImplCopyWithImpl(_$DailyOptionsLoadedImpl _value,
      $Res Function(_$DailyOptionsLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? words = null,
    Object? grammar = null,
    Object? wordsMean = null,
    Object? grammarMean = null,
  }) {
    return _then(_$DailyOptionsLoadedImpl(
      null == words
          ? _value.words
          : words // ignore: cast_nullable_to_non_nullable
              as int,
      null == grammar
          ? _value.grammar
          : grammar // ignore: cast_nullable_to_non_nullable
              as int,
      null == wordsMean
          ? _value.wordsMean
          : wordsMean // ignore: cast_nullable_to_non_nullable
              as int,
      null == grammarMean
          ? _value.grammarMean
          : grammarMean // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$DailyOptionsLoadedImpl implements DailyOptionsLoaded {
  const _$DailyOptionsLoadedImpl(
      this.words, this.grammar, this.wordsMean, this.grammarMean);

  @override
  final int words;
  @override
  final int grammar;
  @override
  final int wordsMean;
  @override
  final int grammarMean;

  @override
  String toString() {
    return 'DailyOptionsState.loaded(words: $words, grammar: $grammar, wordsMean: $wordsMean, grammarMean: $grammarMean)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DailyOptionsLoadedImpl &&
            (identical(other.words, words) || other.words == words) &&
            (identical(other.grammar, grammar) || other.grammar == grammar) &&
            (identical(other.wordsMean, wordsMean) ||
                other.wordsMean == wordsMean) &&
            (identical(other.grammarMean, grammarMean) ||
                other.grammarMean == grammarMean));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, words, grammar, wordsMean, grammarMean);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DailyOptionsLoadedImplCopyWith<_$DailyOptionsLoadedImpl> get copyWith =>
      __$$DailyOptionsLoadedImplCopyWithImpl<_$DailyOptionsLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            int words, int grammar, int wordsMean, int grammarMean)
        loaded,
    required TResult Function() initial,
    required TResult Function() error,
  }) {
    return loaded(words, grammar, wordsMean, grammarMean);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult? Function()? initial,
    TResult? Function()? error,
  }) {
    return loaded?.call(words, grammar, wordsMean, grammarMean);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult Function()? initial,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(words, grammar, wordsMean, grammarMean);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DailyOptionsLoading value) loading,
    required TResult Function(DailyOptionsLoaded value) loaded,
    required TResult Function(DailyOptionsInitial value) initial,
    required TResult Function(DailyOptionsError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DailyOptionsLoading value)? loading,
    TResult? Function(DailyOptionsLoaded value)? loaded,
    TResult? Function(DailyOptionsInitial value)? initial,
    TResult? Function(DailyOptionsError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DailyOptionsLoading value)? loading,
    TResult Function(DailyOptionsLoaded value)? loaded,
    TResult Function(DailyOptionsInitial value)? initial,
    TResult Function(DailyOptionsError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class DailyOptionsLoaded implements DailyOptionsState {
  const factory DailyOptionsLoaded(final int words, final int grammar,
      final int wordsMean, final int grammarMean) = _$DailyOptionsLoadedImpl;

  int get words;
  int get grammar;
  int get wordsMean;
  int get grammarMean;
  @JsonKey(ignore: true)
  _$$DailyOptionsLoadedImplCopyWith<_$DailyOptionsLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DailyOptionsInitialImplCopyWith<$Res> {
  factory _$$DailyOptionsInitialImplCopyWith(_$DailyOptionsInitialImpl value,
          $Res Function(_$DailyOptionsInitialImpl) then) =
      __$$DailyOptionsInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DailyOptionsInitialImplCopyWithImpl<$Res>
    extends _$DailyOptionsStateCopyWithImpl<$Res, _$DailyOptionsInitialImpl>
    implements _$$DailyOptionsInitialImplCopyWith<$Res> {
  __$$DailyOptionsInitialImplCopyWithImpl(_$DailyOptionsInitialImpl _value,
      $Res Function(_$DailyOptionsInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DailyOptionsInitialImpl implements DailyOptionsInitial {
  const _$DailyOptionsInitialImpl();

  @override
  String toString() {
    return 'DailyOptionsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DailyOptionsInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            int words, int grammar, int wordsMean, int grammarMean)
        loaded,
    required TResult Function() initial,
    required TResult Function() error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult? Function()? initial,
    TResult? Function()? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult Function()? initial,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DailyOptionsLoading value) loading,
    required TResult Function(DailyOptionsLoaded value) loaded,
    required TResult Function(DailyOptionsInitial value) initial,
    required TResult Function(DailyOptionsError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DailyOptionsLoading value)? loading,
    TResult? Function(DailyOptionsLoaded value)? loaded,
    TResult? Function(DailyOptionsInitial value)? initial,
    TResult? Function(DailyOptionsError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DailyOptionsLoading value)? loading,
    TResult Function(DailyOptionsLoaded value)? loaded,
    TResult Function(DailyOptionsInitial value)? initial,
    TResult Function(DailyOptionsError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class DailyOptionsInitial implements DailyOptionsState {
  const factory DailyOptionsInitial() = _$DailyOptionsInitialImpl;
}

/// @nodoc
abstract class _$$DailyOptionsErrorImplCopyWith<$Res> {
  factory _$$DailyOptionsErrorImplCopyWith(_$DailyOptionsErrorImpl value,
          $Res Function(_$DailyOptionsErrorImpl) then) =
      __$$DailyOptionsErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DailyOptionsErrorImplCopyWithImpl<$Res>
    extends _$DailyOptionsStateCopyWithImpl<$Res, _$DailyOptionsErrorImpl>
    implements _$$DailyOptionsErrorImplCopyWith<$Res> {
  __$$DailyOptionsErrorImplCopyWithImpl(_$DailyOptionsErrorImpl _value,
      $Res Function(_$DailyOptionsErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DailyOptionsErrorImpl implements DailyOptionsError {
  const _$DailyOptionsErrorImpl();

  @override
  String toString() {
    return 'DailyOptionsState.error()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DailyOptionsErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            int words, int grammar, int wordsMean, int grammarMean)
        loaded,
    required TResult Function() initial,
    required TResult Function() error,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult? Function()? initial,
    TResult? Function()? error,
  }) {
    return error?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(int words, int grammar, int wordsMean, int grammarMean)?
        loaded,
    TResult Function()? initial,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DailyOptionsLoading value) loading,
    required TResult Function(DailyOptionsLoaded value) loaded,
    required TResult Function(DailyOptionsInitial value) initial,
    required TResult Function(DailyOptionsError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DailyOptionsLoading value)? loading,
    TResult? Function(DailyOptionsLoaded value)? loaded,
    TResult? Function(DailyOptionsInitial value)? initial,
    TResult? Function(DailyOptionsError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DailyOptionsLoading value)? loading,
    TResult Function(DailyOptionsLoaded value)? loaded,
    TResult Function(DailyOptionsInitial value)? initial,
    TResult Function(DailyOptionsError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class DailyOptionsError implements DailyOptionsState {
  const factory DailyOptionsError() = _$DailyOptionsErrorImpl;
}
