// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'grammar_mode_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$GrammarModeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() sm2Calculated,
    required TResult Function(int score) scoreCalculated,
    required TResult Function(double score) scoreObtained,
    required TResult Function() testFinished,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? sm2Calculated,
    TResult? Function(int score)? scoreCalculated,
    TResult? Function(double score)? scoreObtained,
    TResult? Function()? testFinished,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? sm2Calculated,
    TResult Function(int score)? scoreCalculated,
    TResult Function(double score)? scoreObtained,
    TResult Function()? testFinished,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GrammarModeLoading value) loading,
    required TResult Function(GrammarModeLoaded value) loaded,
    required TResult Function(GrammarModeSM2Calculated value) sm2Calculated,
    required TResult Function(GrammarModeScoreCalculated value) scoreCalculated,
    required TResult Function(GrammarModeScoreObtained value) scoreObtained,
    required TResult Function(GrammarModeTestFinished value) testFinished,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GrammarModeLoading value)? loading,
    TResult? Function(GrammarModeLoaded value)? loaded,
    TResult? Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult? Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult? Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult? Function(GrammarModeTestFinished value)? testFinished,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GrammarModeLoading value)? loading,
    TResult Function(GrammarModeLoaded value)? loaded,
    TResult Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult Function(GrammarModeTestFinished value)? testFinished,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GrammarModeStateCopyWith<$Res> {
  factory $GrammarModeStateCopyWith(
          GrammarModeState value, $Res Function(GrammarModeState) then) =
      _$GrammarModeStateCopyWithImpl<$Res, GrammarModeState>;
}

/// @nodoc
class _$GrammarModeStateCopyWithImpl<$Res, $Val extends GrammarModeState>
    implements $GrammarModeStateCopyWith<$Res> {
  _$GrammarModeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$GrammarModeLoadingImplCopyWith<$Res> {
  factory _$$GrammarModeLoadingImplCopyWith(_$GrammarModeLoadingImpl value,
          $Res Function(_$GrammarModeLoadingImpl) then) =
      __$$GrammarModeLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GrammarModeLoadingImplCopyWithImpl<$Res>
    extends _$GrammarModeStateCopyWithImpl<$Res, _$GrammarModeLoadingImpl>
    implements _$$GrammarModeLoadingImplCopyWith<$Res> {
  __$$GrammarModeLoadingImplCopyWithImpl(_$GrammarModeLoadingImpl _value,
      $Res Function(_$GrammarModeLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GrammarModeLoadingImpl implements GrammarModeLoading {
  const _$GrammarModeLoadingImpl();

  @override
  String toString() {
    return 'GrammarModeState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GrammarModeLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() sm2Calculated,
    required TResult Function(int score) scoreCalculated,
    required TResult Function(double score) scoreObtained,
    required TResult Function() testFinished,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? sm2Calculated,
    TResult? Function(int score)? scoreCalculated,
    TResult? Function(double score)? scoreObtained,
    TResult? Function()? testFinished,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? sm2Calculated,
    TResult Function(int score)? scoreCalculated,
    TResult Function(double score)? scoreObtained,
    TResult Function()? testFinished,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GrammarModeLoading value) loading,
    required TResult Function(GrammarModeLoaded value) loaded,
    required TResult Function(GrammarModeSM2Calculated value) sm2Calculated,
    required TResult Function(GrammarModeScoreCalculated value) scoreCalculated,
    required TResult Function(GrammarModeScoreObtained value) scoreObtained,
    required TResult Function(GrammarModeTestFinished value) testFinished,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GrammarModeLoading value)? loading,
    TResult? Function(GrammarModeLoaded value)? loaded,
    TResult? Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult? Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult? Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult? Function(GrammarModeTestFinished value)? testFinished,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GrammarModeLoading value)? loading,
    TResult Function(GrammarModeLoaded value)? loaded,
    TResult Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult Function(GrammarModeTestFinished value)? testFinished,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class GrammarModeLoading implements GrammarModeState {
  const factory GrammarModeLoading() = _$GrammarModeLoadingImpl;
}

/// @nodoc
abstract class _$$GrammarModeLoadedImplCopyWith<$Res> {
  factory _$$GrammarModeLoadedImplCopyWith(_$GrammarModeLoadedImpl value,
          $Res Function(_$GrammarModeLoadedImpl) then) =
      __$$GrammarModeLoadedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GrammarModeLoadedImplCopyWithImpl<$Res>
    extends _$GrammarModeStateCopyWithImpl<$Res, _$GrammarModeLoadedImpl>
    implements _$$GrammarModeLoadedImplCopyWith<$Res> {
  __$$GrammarModeLoadedImplCopyWithImpl(_$GrammarModeLoadedImpl _value,
      $Res Function(_$GrammarModeLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GrammarModeLoadedImpl implements GrammarModeLoaded {
  const _$GrammarModeLoadedImpl();

  @override
  String toString() {
    return 'GrammarModeState.loaded()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GrammarModeLoadedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() sm2Calculated,
    required TResult Function(int score) scoreCalculated,
    required TResult Function(double score) scoreObtained,
    required TResult Function() testFinished,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? sm2Calculated,
    TResult? Function(int score)? scoreCalculated,
    TResult? Function(double score)? scoreObtained,
    TResult? Function()? testFinished,
  }) {
    return loaded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? sm2Calculated,
    TResult Function(int score)? scoreCalculated,
    TResult Function(double score)? scoreObtained,
    TResult Function()? testFinished,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GrammarModeLoading value) loading,
    required TResult Function(GrammarModeLoaded value) loaded,
    required TResult Function(GrammarModeSM2Calculated value) sm2Calculated,
    required TResult Function(GrammarModeScoreCalculated value) scoreCalculated,
    required TResult Function(GrammarModeScoreObtained value) scoreObtained,
    required TResult Function(GrammarModeTestFinished value) testFinished,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GrammarModeLoading value)? loading,
    TResult? Function(GrammarModeLoaded value)? loaded,
    TResult? Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult? Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult? Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult? Function(GrammarModeTestFinished value)? testFinished,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GrammarModeLoading value)? loading,
    TResult Function(GrammarModeLoaded value)? loaded,
    TResult Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult Function(GrammarModeTestFinished value)? testFinished,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class GrammarModeLoaded implements GrammarModeState {
  const factory GrammarModeLoaded() = _$GrammarModeLoadedImpl;
}

/// @nodoc
abstract class _$$GrammarModeSM2CalculatedImplCopyWith<$Res> {
  factory _$$GrammarModeSM2CalculatedImplCopyWith(
          _$GrammarModeSM2CalculatedImpl value,
          $Res Function(_$GrammarModeSM2CalculatedImpl) then) =
      __$$GrammarModeSM2CalculatedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GrammarModeSM2CalculatedImplCopyWithImpl<$Res>
    extends _$GrammarModeStateCopyWithImpl<$Res, _$GrammarModeSM2CalculatedImpl>
    implements _$$GrammarModeSM2CalculatedImplCopyWith<$Res> {
  __$$GrammarModeSM2CalculatedImplCopyWithImpl(
      _$GrammarModeSM2CalculatedImpl _value,
      $Res Function(_$GrammarModeSM2CalculatedImpl) _then)
      : super(_value, _then);

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GrammarModeSM2CalculatedImpl implements GrammarModeSM2Calculated {
  const _$GrammarModeSM2CalculatedImpl();

  @override
  String toString() {
    return 'GrammarModeState.sm2Calculated()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GrammarModeSM2CalculatedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() sm2Calculated,
    required TResult Function(int score) scoreCalculated,
    required TResult Function(double score) scoreObtained,
    required TResult Function() testFinished,
  }) {
    return sm2Calculated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? sm2Calculated,
    TResult? Function(int score)? scoreCalculated,
    TResult? Function(double score)? scoreObtained,
    TResult? Function()? testFinished,
  }) {
    return sm2Calculated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? sm2Calculated,
    TResult Function(int score)? scoreCalculated,
    TResult Function(double score)? scoreObtained,
    TResult Function()? testFinished,
    required TResult orElse(),
  }) {
    if (sm2Calculated != null) {
      return sm2Calculated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GrammarModeLoading value) loading,
    required TResult Function(GrammarModeLoaded value) loaded,
    required TResult Function(GrammarModeSM2Calculated value) sm2Calculated,
    required TResult Function(GrammarModeScoreCalculated value) scoreCalculated,
    required TResult Function(GrammarModeScoreObtained value) scoreObtained,
    required TResult Function(GrammarModeTestFinished value) testFinished,
  }) {
    return sm2Calculated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GrammarModeLoading value)? loading,
    TResult? Function(GrammarModeLoaded value)? loaded,
    TResult? Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult? Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult? Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult? Function(GrammarModeTestFinished value)? testFinished,
  }) {
    return sm2Calculated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GrammarModeLoading value)? loading,
    TResult Function(GrammarModeLoaded value)? loaded,
    TResult Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult Function(GrammarModeTestFinished value)? testFinished,
    required TResult orElse(),
  }) {
    if (sm2Calculated != null) {
      return sm2Calculated(this);
    }
    return orElse();
  }
}

abstract class GrammarModeSM2Calculated implements GrammarModeState {
  const factory GrammarModeSM2Calculated() = _$GrammarModeSM2CalculatedImpl;
}

/// @nodoc
abstract class _$$GrammarModeScoreCalculatedImplCopyWith<$Res> {
  factory _$$GrammarModeScoreCalculatedImplCopyWith(
          _$GrammarModeScoreCalculatedImpl value,
          $Res Function(_$GrammarModeScoreCalculatedImpl) then) =
      __$$GrammarModeScoreCalculatedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int score});
}

/// @nodoc
class __$$GrammarModeScoreCalculatedImplCopyWithImpl<$Res>
    extends _$GrammarModeStateCopyWithImpl<$Res,
        _$GrammarModeScoreCalculatedImpl>
    implements _$$GrammarModeScoreCalculatedImplCopyWith<$Res> {
  __$$GrammarModeScoreCalculatedImplCopyWithImpl(
      _$GrammarModeScoreCalculatedImpl _value,
      $Res Function(_$GrammarModeScoreCalculatedImpl) _then)
      : super(_value, _then);

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
  }) {
    return _then(_$GrammarModeScoreCalculatedImpl(
      null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$GrammarModeScoreCalculatedImpl implements GrammarModeScoreCalculated {
  const _$GrammarModeScoreCalculatedImpl(this.score);

  @override
  final int score;

  @override
  String toString() {
    return 'GrammarModeState.scoreCalculated(score: $score)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GrammarModeScoreCalculatedImpl &&
            (identical(other.score, score) || other.score == score));
  }

  @override
  int get hashCode => Object.hash(runtimeType, score);

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GrammarModeScoreCalculatedImplCopyWith<_$GrammarModeScoreCalculatedImpl>
      get copyWith => __$$GrammarModeScoreCalculatedImplCopyWithImpl<
          _$GrammarModeScoreCalculatedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() sm2Calculated,
    required TResult Function(int score) scoreCalculated,
    required TResult Function(double score) scoreObtained,
    required TResult Function() testFinished,
  }) {
    return scoreCalculated(score);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? sm2Calculated,
    TResult? Function(int score)? scoreCalculated,
    TResult? Function(double score)? scoreObtained,
    TResult? Function()? testFinished,
  }) {
    return scoreCalculated?.call(score);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? sm2Calculated,
    TResult Function(int score)? scoreCalculated,
    TResult Function(double score)? scoreObtained,
    TResult Function()? testFinished,
    required TResult orElse(),
  }) {
    if (scoreCalculated != null) {
      return scoreCalculated(score);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GrammarModeLoading value) loading,
    required TResult Function(GrammarModeLoaded value) loaded,
    required TResult Function(GrammarModeSM2Calculated value) sm2Calculated,
    required TResult Function(GrammarModeScoreCalculated value) scoreCalculated,
    required TResult Function(GrammarModeScoreObtained value) scoreObtained,
    required TResult Function(GrammarModeTestFinished value) testFinished,
  }) {
    return scoreCalculated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GrammarModeLoading value)? loading,
    TResult? Function(GrammarModeLoaded value)? loaded,
    TResult? Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult? Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult? Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult? Function(GrammarModeTestFinished value)? testFinished,
  }) {
    return scoreCalculated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GrammarModeLoading value)? loading,
    TResult Function(GrammarModeLoaded value)? loaded,
    TResult Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult Function(GrammarModeTestFinished value)? testFinished,
    required TResult orElse(),
  }) {
    if (scoreCalculated != null) {
      return scoreCalculated(this);
    }
    return orElse();
  }
}

abstract class GrammarModeScoreCalculated implements GrammarModeState {
  const factory GrammarModeScoreCalculated(final int score) =
      _$GrammarModeScoreCalculatedImpl;

  int get score;

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GrammarModeScoreCalculatedImplCopyWith<_$GrammarModeScoreCalculatedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GrammarModeScoreObtainedImplCopyWith<$Res> {
  factory _$$GrammarModeScoreObtainedImplCopyWith(
          _$GrammarModeScoreObtainedImpl value,
          $Res Function(_$GrammarModeScoreObtainedImpl) then) =
      __$$GrammarModeScoreObtainedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double score});
}

/// @nodoc
class __$$GrammarModeScoreObtainedImplCopyWithImpl<$Res>
    extends _$GrammarModeStateCopyWithImpl<$Res, _$GrammarModeScoreObtainedImpl>
    implements _$$GrammarModeScoreObtainedImplCopyWith<$Res> {
  __$$GrammarModeScoreObtainedImplCopyWithImpl(
      _$GrammarModeScoreObtainedImpl _value,
      $Res Function(_$GrammarModeScoreObtainedImpl) _then)
      : super(_value, _then);

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
  }) {
    return _then(_$GrammarModeScoreObtainedImpl(
      null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$GrammarModeScoreObtainedImpl implements GrammarModeScoreObtained {
  const _$GrammarModeScoreObtainedImpl(this.score);

  @override
  final double score;

  @override
  String toString() {
    return 'GrammarModeState.scoreObtained(score: $score)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GrammarModeScoreObtainedImpl &&
            (identical(other.score, score) || other.score == score));
  }

  @override
  int get hashCode => Object.hash(runtimeType, score);

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GrammarModeScoreObtainedImplCopyWith<_$GrammarModeScoreObtainedImpl>
      get copyWith => __$$GrammarModeScoreObtainedImplCopyWithImpl<
          _$GrammarModeScoreObtainedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() sm2Calculated,
    required TResult Function(int score) scoreCalculated,
    required TResult Function(double score) scoreObtained,
    required TResult Function() testFinished,
  }) {
    return scoreObtained(score);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? sm2Calculated,
    TResult? Function(int score)? scoreCalculated,
    TResult? Function(double score)? scoreObtained,
    TResult? Function()? testFinished,
  }) {
    return scoreObtained?.call(score);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? sm2Calculated,
    TResult Function(int score)? scoreCalculated,
    TResult Function(double score)? scoreObtained,
    TResult Function()? testFinished,
    required TResult orElse(),
  }) {
    if (scoreObtained != null) {
      return scoreObtained(score);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GrammarModeLoading value) loading,
    required TResult Function(GrammarModeLoaded value) loaded,
    required TResult Function(GrammarModeSM2Calculated value) sm2Calculated,
    required TResult Function(GrammarModeScoreCalculated value) scoreCalculated,
    required TResult Function(GrammarModeScoreObtained value) scoreObtained,
    required TResult Function(GrammarModeTestFinished value) testFinished,
  }) {
    return scoreObtained(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GrammarModeLoading value)? loading,
    TResult? Function(GrammarModeLoaded value)? loaded,
    TResult? Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult? Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult? Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult? Function(GrammarModeTestFinished value)? testFinished,
  }) {
    return scoreObtained?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GrammarModeLoading value)? loading,
    TResult Function(GrammarModeLoaded value)? loaded,
    TResult Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult Function(GrammarModeTestFinished value)? testFinished,
    required TResult orElse(),
  }) {
    if (scoreObtained != null) {
      return scoreObtained(this);
    }
    return orElse();
  }
}

abstract class GrammarModeScoreObtained implements GrammarModeState {
  const factory GrammarModeScoreObtained(final double score) =
      _$GrammarModeScoreObtainedImpl;

  double get score;

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GrammarModeScoreObtainedImplCopyWith<_$GrammarModeScoreObtainedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GrammarModeTestFinishedImplCopyWith<$Res> {
  factory _$$GrammarModeTestFinishedImplCopyWith(
          _$GrammarModeTestFinishedImpl value,
          $Res Function(_$GrammarModeTestFinishedImpl) then) =
      __$$GrammarModeTestFinishedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GrammarModeTestFinishedImplCopyWithImpl<$Res>
    extends _$GrammarModeStateCopyWithImpl<$Res, _$GrammarModeTestFinishedImpl>
    implements _$$GrammarModeTestFinishedImplCopyWith<$Res> {
  __$$GrammarModeTestFinishedImplCopyWithImpl(
      _$GrammarModeTestFinishedImpl _value,
      $Res Function(_$GrammarModeTestFinishedImpl) _then)
      : super(_value, _then);

  /// Create a copy of GrammarModeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GrammarModeTestFinishedImpl implements GrammarModeTestFinished {
  const _$GrammarModeTestFinishedImpl();

  @override
  String toString() {
    return 'GrammarModeState.testFinished()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GrammarModeTestFinishedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() sm2Calculated,
    required TResult Function(int score) scoreCalculated,
    required TResult Function(double score) scoreObtained,
    required TResult Function() testFinished,
  }) {
    return testFinished();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? sm2Calculated,
    TResult? Function(int score)? scoreCalculated,
    TResult? Function(double score)? scoreObtained,
    TResult? Function()? testFinished,
  }) {
    return testFinished?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? sm2Calculated,
    TResult Function(int score)? scoreCalculated,
    TResult Function(double score)? scoreObtained,
    TResult Function()? testFinished,
    required TResult orElse(),
  }) {
    if (testFinished != null) {
      return testFinished();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GrammarModeLoading value) loading,
    required TResult Function(GrammarModeLoaded value) loaded,
    required TResult Function(GrammarModeSM2Calculated value) sm2Calculated,
    required TResult Function(GrammarModeScoreCalculated value) scoreCalculated,
    required TResult Function(GrammarModeScoreObtained value) scoreObtained,
    required TResult Function(GrammarModeTestFinished value) testFinished,
  }) {
    return testFinished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GrammarModeLoading value)? loading,
    TResult? Function(GrammarModeLoaded value)? loaded,
    TResult? Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult? Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult? Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult? Function(GrammarModeTestFinished value)? testFinished,
  }) {
    return testFinished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GrammarModeLoading value)? loading,
    TResult Function(GrammarModeLoaded value)? loaded,
    TResult Function(GrammarModeSM2Calculated value)? sm2Calculated,
    TResult Function(GrammarModeScoreCalculated value)? scoreCalculated,
    TResult Function(GrammarModeScoreObtained value)? scoreObtained,
    TResult Function(GrammarModeTestFinished value)? testFinished,
    required TResult orElse(),
  }) {
    if (testFinished != null) {
      return testFinished(this);
    }
    return orElse();
  }
}

abstract class GrammarModeTestFinished implements GrammarModeState {
  const factory GrammarModeTestFinished() = _$GrammarModeTestFinishedImpl;
}
